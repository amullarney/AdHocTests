-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("6a4a82e9-5119-463b-b210-5e00c3ece052",
	"00000000-0000-0000-0000-000000000000",
	"846e9e70-104d-4678-8694-b2e3922e335a",
	'TestFunctions',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("c5df5776-d86a-449a-b794-4d7eb5cea450",
	112,
	"6a4a82e9-5119-463b-b210-5e00c3ece052",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'',
	'Tests::Components::Test::TestFunctions');
INSERT INTO DIM_DIA
	VALUES ("c5df5776-d86a-449a-b794-4d7eb5cea450",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("e1211753-7625-4a68-abd8-3c4efad88d4b",
	"00000000-0000-0000-0000-000000000000",
	'testSym',
	'',
	'create object instance man of person;
man.name = "Jack";
create object instance wife of person;
wife.name = "Jill";
create object instance lic of Licence; 
relate man to wife across R7.''is wed to'' using lic;
select one woman related by man->person[R7.''is wed to''];
if ( not_empty woman )
  LOG::LogInfo( message:"woman is: " + woman.name );
else
  LOG::LogFailure( message:"hmm.." );
end if;

select one l related by woman->Licence[R7.''is wed to''];
select any body related by l->person[R7.''is wed to''];
if ( not_empty body )
  LOG::LogInfo( message:"from licence we got: " + body.name );
end if;

select any spouse related by lic->person[R7.''is wed to''];
select any other related by lic->person[R7.''is wed to''] where ( selected.name != spouse.name );
LOG::LogInfo( message:"spouse is: " + spouse.name );
LOG::LogInfo( message:"other is: " + other.name );
select many people related by lic->person[R7.''is wed to''];
LOG::LogInfo( message:"select many.." );
for each person in people
  LOG::LogInfo( message:"person is: " + person.name );
end for;

/*create object instance friend of person;
relate friend to man across R10.''is aquainted with'';
relate friend to wife across R10.''is aquainted with'';
select many aquaintances related by friend->person[R10.''is aquainted with''];
for each aq in aquaintances
  LOG::LogInfo( message:"friend knows: " + aq.name );
end for;
*/

create object instance b1 of boy;
create object instance b2 of boy;
create object instance b3 of boy;
create object instance b4 of boy;
relate b1 to b2 across R10.''plays with'';
relate b4 to b3 across R10.''plays with'';
select one playmate related by b1->boy[R10.''plays with''];
unrelate b2 from b1 across R10.''plays with'';
unrelate b3 from b4 across R10.''plays with'';

unrelate man from wife across R7.''is wed to'' using lic;
select one ex related by man->person[R7.''is wed to''];
if ( not_empty ex )
  LOG::LogFailure( message:"hmm.." );
end if;

create object instance USA of Territory;
USA.Name = "USA";

create object instance Mexico of Territory;
Mexico.Name = "Mexico";
relate USA to Mexico across R1.''is adjacent to'';
select any t related by Mexico->Territory[R1.''is adjacent to''];
LOG::LogInfo( message:t.Name );
unrelate USA from Mexico across R1.''is adjacent to'';


create object instance x of city;
x.name = "Dublin";
create object instance y of city;
y.name = "Cork";
create object instance r1 of route;
r1.toll = true;
relate x to y across R8.''is reachable from'' using r1;
create object instance r2 of route;
relate x to y across R8.''is reachable from'' using r2;
select any z related by x->city[R8.''is reachable from''];
LOG::LogInfo( message:"reached: " + z.name );
select many routes related by x->route[R8.''is reachable from''];
LOG::LogInteger( message:cardinality routes );
select many cities related by r1->city[R8.''is reachable from''];
LOG::LogInfo( message:"r1 joins cities" );
LOG::LogInteger( message:cardinality cities );

create object instance az of state;
az.name = "AZ";
create object instance nm of state;
nm.name = "NM";
create object instance ca of state;
ca.name = "CA";
create object instance aznm of border;
create object instance azca of border;
relate az to ca across R9.''is adjacent to'' using azca;
relate az to nm across R9.''is adjacent to'' using aznm;
select many states related by az->state[R9.''is adjacent to''];
LOG::LogInfo( message:"AZ borders" );
LOG::LogInteger( message:cardinality states );






',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	1);
INSERT INTO PE_PE
	VALUES ("e1211753-7625-4a68-abd8-3c4efad88d4b",
	1,
	"6a4a82e9-5119-463b-b210-5e00c3ece052",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("6a4a82e9-5119-463b-b210-5e00c3ece052",
	1,
	"00000000-0000-0000-0000-000000000000",
	"7bf54281-dcf1-4f23-91f6-05c5083cfd18",
	7);
INSERT INTO C_C_PROXY
	VALUES ("7bf54281-dcf1-4f23-91f6-05c5083cfd18",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	'Test',
	'Two test functions exercise one-shot and recurring timers.

When run deterministically - with simulated time ( no choice but to do so ) the action is as expected.
Log messages stream continuously to the console.

When run deterministically is unchecked - simulated time is still checked - nothing happens. (And restart does not alter this).

When simulated time is unchecked( and deterministically unchecked ) log messages arrive separated in real time - as expected. 
( This requires restart if simulated time has been run ).',
	0,
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'',
	'../Test.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("846e9e70-104d-4678-8694-b2e3922e335a",
	'Tests',
	1,
	'../../../Tests.xtuml');
